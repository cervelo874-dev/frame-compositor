<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Frame Compositor - Magic Wand Edition</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Roboto:wght@300;400;500&display=swap"
        rel="stylesheet">
    <!-- Fabric.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        :root {
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --accent-color: #00d2ff;
            --text-color: #ffffff;
            --danger-color: #ff4b4b;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', 'Roboto', sans-serif;
            background: linear-gradient(-45deg, #0f2027, #203a43, #2c5364, #240b36);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        @keyframes gradientBG {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .glass-container {
            background: var(--glass-bg);
            box-shadow: var(--glass-shadow);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        header {
            padding: 1.5rem;
            text-align: center;
            border-bottom: 1px solid var(--glass-border);
        }

        h1 {
            font-size: 1.25rem;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Canvas Area */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            /* Remove padding-top hack, use JS driven aspect-ratio or strict sizing */
            max-height: 60vh;
            /* Limit height to 60% of viewport height */
            margin: 0 auto;
            /* Center horizontally */
            background-color: #2a2a2a;
            background-image:
                linear-gradient(45deg, #333 25%, transparent 25%),
                linear-gradient(-45deg, #333 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #333 75%),
                linear-gradient(-45deg, transparent 75%, #333 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            overflow: hidden;
            cursor: crosshair;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .canvas-container-inner {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Force Fabric's container to be responsive */
        .canvas-container {
            width: 100% !important;
            height: 100% !important;
        }

        .canvas-container canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* Controls */
        .controls {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        label {
            font-size: 0.85rem;
            opacity: 0.9;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Custom File Input */
        .file-input-wrapper {
            position: relative;
            width: 100%;
        }

        .file-input-btn {
            display: block;
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            color: #fff;
            text-align: center;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-input-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: var(--accent-color);
        }

        input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        /* Tolerance Slider */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.5);
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        /* Segmented Control */
        .segmented-control {
            display: flex;
            background: rgba(0, 0, 0, 0.2);
            padding: 4px;
            border-radius: 12px;
            margin-bottom: 1rem;
        }

        .segment-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .segment-btn.active {
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            color: var(--accent-color);
        }

        /* Action Buttons */
        .btn-row {
            display: flex;
            gap: 10px;
        }

        .primary-btn,
        .secondary-btn,
        .reset-btn {
            padding: 14px;
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            flex: 1;
            text-align: center;
        }

        .primary-btn {
            background: var(--primary-gradient);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .reset-btn {
            background: rgba(255, 75, 75, 0.6);
            border: 1px solid rgba(255, 75, 75, 0.4);
            font-size: 0.9rem;
            flex: 0 0 auto;
            /* Don't grow too much */
            width: 80px;
            padding: 8px;
        }

        .primary-btn:active,
        .reset-btn:active {
            transform: scale(0.98);
        }

        .hint-text {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 4px;
            line-height: 1.4;
            background: rgba(0, 0, 0, 0.2);
            padding: 8px;
            border-radius: 8px;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>

    <div id="loading">
        <div class="spinner"></div>
    </div>

    <div class="glass-container">
        <header>
            <h1>Frame Compositor</h1>
        </header>

        <div class="canvas-wrapper" id="canvasWrapper">
            <div class="canvas-container-inner">
                <!-- IMPORTANT: Canvas element -->
                <canvas id="c"></canvas>
            </div>
        </div>

        <div class="controls">
            <!-- Mode Switcher -->
            <div class="segmented-control">
                <button class="segment-btn active" id="modeWand" onclick="setMode('wand')">ğŸª„ åˆ‡ã‚ŠæŠœã</button>
                <button class="segment-btn" id="modeMove" onclick="setMode('move')">âœ‹ é…ç½®ãƒ»ç·¨é›†</button>
            </div>

            <!-- 1. Frame Upload -->
            <div class="control-group">
                <label>
                    <span>1. ãƒ•ãƒ¬ãƒ¼ãƒ ç”»åƒ (ä¸Šå±¤)</span>
                    <button class="reset-btn" id="resetFrameBtn">ãƒªã‚»ãƒƒãƒˆ</button>
                </label>
                <div class="file-input-wrapper">
                    <div class="file-input-btn">ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é¸æŠã¾ãŸã¯æ’®å½±</div>
                    <input type="file" id="uploadFrame" accept="image/*">
                </div>
                <!-- Tolerance Slider -->
                <div style="margin-top: 10px;">
                    <label style="font-size: 0.8rem; margin-bottom: 5px;">
                        è¨±å®¹å€¤ <span id="thresholdValue">40</span>
                    </label>
                    <input type="range" id="thresholdRange" min="1" max="150" value="40">
                </div>
                <p class="hint-text">ğŸ’¡ ç”»åƒã®æ¶ˆã—ãŸã„éƒ¨åˆ†ï¼ˆç™½ãªã©ï¼‰ã‚’<strong>ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—</strong>ã—ã¦ãã ã•ã„ã€‚è‡ªå‹•é¸æŠãƒ„ãƒ¼ãƒ«ã®ã‚ˆã†ã«é€æ˜ã«ãªã‚Šã¾ã™ã€‚</p>
            </div>

            <!-- 2. Photo Upload -->
            <div class="control-group">
                <label>2. å†™çœŸ (ä¸‹å±¤ãƒ»è¤‡æ•°å¯) <span id="photoName"></span></label>
                <div class="file-input-wrapper">
                    <div class="file-input-btn">å†™çœŸã‚’é¸æŠã¾ãŸã¯æ’®å½± (è¤‡æ•°å¯)</div>
                    <input type="file" id="uploadPhoto" accept="image/*" multiple>
                </div>
                <button class="secondary-btn" id="deletePhotoBtn"
                    style="margin-top: 10px; background: rgba(255, 75, 75, 0.4); font-size: 0.9rem;">é¸æŠã—ãŸå†™çœŸã‚’å‰Šé™¤</button>
            </div>

            <!-- Save Button -->
            <button class="primary-btn" id="saveBtn">ç”»åƒã‚’ä¿å­˜ (PNG)</button>
        </div>
    </div>

    <script>
        // -- Fabric.js Customization (Better Visibility) --
        fabric.Object.prototype.set({
            borderColor: '#00d2ff',       // Cyan border
            cornerColor: '#ffffff',       // White corners
            cornerStrokeColor: '#00d2ff', // Cyan stroke on corners
            cornerSize: 20,               // Large corners
            transparentCorners: false,    // Solid feel
            borderScaleFactor: 2,         // Thicker border
            touchCornerSize: 24,          // Touch friendly
            padding: 5                    // Space around object
        });

        document.addEventListener('DOMContentLoaded', () => {
            // -- Elements --
            const uploadFrameBtn = document.getElementById('uploadFrame');
            const uploadPhotoBtn = document.getElementById('uploadPhoto');
            const thresholdRange = document.getElementById('thresholdRange');
            const thresholdValue = document.getElementById('thresholdValue');
            const saveBtn = document.getElementById('saveBtn');
            const resetFrameBtn = document.getElementById('resetFrameBtn');
            const loadingOverlay = document.getElementById('loading');
            const photoName = document.getElementById('photoName');

            // Mode Buttons
            const modeWandBtn = document.getElementById('modeWand');
            const modeMoveBtn = document.getElementById('modeMove');

            // -- State --
            let frameImgObj = null; // Fabric Image Object
            let currentFrameImageData = null; // Current ImageData state (canvas 2d)
            let originalFrameImageData = null; // Backup for reset
            let currentMode = 'wand'; // 'wand' or 'move'

            // REMOVED fixed canvasSize. We use the Frame size now.
            let canvasBaseWidth = 800; // Default placeholder
            let canvasBaseHeight = 800;

            // -- Mode Switch Logic --
            window.setMode = (mode) => {
                currentMode = mode;

                // UI Update
                if (mode === 'wand') {
                    modeWandBtn.classList.add('active');
                    modeMoveBtn.classList.remove('active');
                    canvas.defaultCursor = 'crosshair';
                    canvas.hoverCursor = 'crosshair';
                } else {
                    modeWandBtn.classList.remove('active');
                    modeMoveBtn.classList.add('active');
                    canvas.defaultCursor = 'default';
                    canvas.hoverCursor = 'move';
                }

                // Logic Update
                const objects = canvas.getObjects();
                objects.forEach(obj => {
                    if (obj === frameImgObj) {
                        // Frame behavior
                        if (mode === 'wand') {
                            // Wand Mode: Frame catches interactions (for clicking)
                            obj.evented = true;
                            obj.selectable = false;
                        } else {
                            // Move Mode: Frame is "ghost" (clicks pass through)
                            obj.evented = false;
                            obj.selectable = false;
                        }
                    } else {
                        // Photo behavior
                        if (mode === 'wand') {
                            // Wand Mode: Photos are background, not touchable
                            obj.selectable = false;
                            obj.evented = false;
                        } else {
                            // Move Mode: Photos are fully editable
                            obj.selectable = true;
                            obj.evented = true;
                        }
                    }
                });

                canvas.discardActiveObject();
                canvas.requestRenderAll();
            };

            // -- Helper: Show/Hide Loading --
            const setLoading = (isLoading) => {
                loadingOverlay.style.display = isLoading ? 'flex' : 'none';
            };

            // -- Fabric Canvas Init --
            const canvas = new fabric.Canvas('c', {
                width: canvasBaseWidth,
                height: canvasBaseHeight,
                preserveObjectStacking: true,
                selection: true, // Enable selection (important for Move mode)
                perPixelTargetFind: true, // Needed to detect clicks on frame
            });

            // Initial Mode Setup
            // (Wait a tick to ensure canvas is ready if needed, though sequential exec is fine)
            // We need to re-apply mode settings whenever objects are added
            const applyModeSettings = () => {
                window.setMode(currentMode);
            };

            // -- Fabric Canvas Init --
            const resizeCanvas = () => {
                const wrapper = document.getElementById('canvasWrapper');
                const canvasEl = canvas.getElement();

                // Allow canvas element to visually fill the wrapper
                canvasEl.style.width = '100%';
                canvasEl.style.height = '100%';

                if (canvasBaseWidth > 0 && canvasBaseHeight > 0) {
                    // Check available space from parent container
                    // The wrapper is inside .glass-container which has max-width: 500px
                    const parentWidth = wrapper.parentElement ? wrapper.parentElement.clientWidth : window.innerWidth;

                    // Constrain Max Width to parent width (minus potential padding if any, though here it is full width)
                    const MAX_W = Math.min(window.innerWidth * 0.95, parentWidth);
                    const MAX_H = window.innerHeight * 0.6;

                    const aspect = canvasBaseWidth / canvasBaseHeight;

                    let finalW = MAX_W;
                    let finalH = finalW / aspect;

                    // If height exceeds max height, constrain by height
                    if (finalH > MAX_H) {
                        finalH = MAX_H;
                        finalW = finalH * aspect;
                    }

                    // Apply explicit pixel size to wrapper
                    wrapper.style.width = `${finalW}px`;
                    wrapper.style.height = `${finalH}px`;
                    wrapper.style.aspectRatio = 'auto'; // Disable CSS aspect ratio
                    wrapper.style.paddingTop = '0';
                }
            };
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // -- Flood Fill Algorithm --
            const floodFillScanline = (pixels, width, height, startX, startY, targetR, targetG, targetB, targetA, tolerance) => {
                // Determine start index
                const startPos = (startY * width + startX) * 4;

                // If already transparent, return
                if (pixels[startPos + 3] === 0) return;

                // Helper to check color match
                const matches = (pos) => {
                    const r = pixels[pos];
                    const g = pixels[pos + 1];
                    const b = pixels[pos + 2];
                    const a = pixels[pos + 3];

                    // Don't fill if already transparent
                    if (a === 0) return false;

                    const diff = Math.abs(r - targetR) + Math.abs(g - targetG) + Math.abs(b - targetB);
                    // Also check alpha if needed, but assuming opaque frame mostly
                    return diff <= tolerance;
                };

                const queue = [[startX, startY]];
                const seen = new Uint8Array(width * height); // Simple visited map

                while (queue.length > 0) {
                    const [cx, cy] = queue.pop();
                    const pos = (cy * width + cx) * 4;

                    if (seen[cy * width + cx]) continue;

                    if (matches(pos)) {
                        // Apply transparency
                        pixels[pos + 3] = 0;
                        seen[cy * width + cx] = 1;

                        // Check neighbors
                        if (cx > 0) queue.push([cx - 1, cy]);
                        if (cx < width - 1) queue.push([cx + 1, cy]);
                        if (cy > 0) queue.push([cx, cy - 1]);
                        if (cy < height - 1) queue.push([cx, cy + 1]);
                    }
                }
            }

            // -- Canvas Interaction (Flood Fill) --
            canvas.on('mouse:down', (options) => {
                // Only process if clicking on the Frame layer
                if (!options.target || options.target !== frameImgObj) return;

                setLoading(true);

                // Pointer is relative to canvas element (scaled by CSS).
                // Fabric.js getPointer is smart, it usually handles scaling if configured right.
                // But with pure CSS scaling, we might receive coordinates relative to visual size.
                // We need to map them to internal canvas size.

                const pointer = canvas.getPointer(options.e);
                // pointer is in target logic coordinates.

                const x = Math.floor(pointer.x);
                const y = Math.floor(pointer.y);

                setTimeout(() => {
                    if (!currentFrameImageData) {
                        setLoading(false);
                        return;
                    }

                    const width = currentFrameImageData.width;
                    const height = currentFrameImageData.height;

                    const finalIx = x;
                    const finalIy = y;

                    // Bounds check
                    if (finalIx < 0 || finalIx >= width || finalIy < 0 || finalIy >= height) {
                        setLoading(false);
                        return;
                    }

                    // Get Target Color
                    const data = currentFrameImageData.data;
                    const pos = (finalIy * width + finalIx) * 4;
                    const targetR = data[pos];
                    const targetG = data[pos + 1];
                    const targetB = data[pos + 2];
                    const targetA = data[pos + 3];

                    if (targetA === 0) {
                        setLoading(false);
                        return;
                    }

                    // Execute Flood Fill
                    const tolerance = parseInt(thresholdRange.value) * 3;
                    floodFillScanline(data, width, height, finalIx, finalIy, targetR, targetG, targetB, targetA, tolerance);

                    // Update Fabric Object
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.putImageData(currentFrameImageData, 0, 0);

                    const newUrl = tempCanvas.toDataURL();
                    frameImgObj.setSrc(newUrl, () => {
                        canvas.renderAll();
                        setLoading(false);
                    });

                }, 50);
            });

            // -- 1. Frame Upload Logic --
            uploadFrameBtn.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                setLoading(true);

                const reader = new FileReader();
                reader.onload = (f) => {
                    const imgObj = new Image();
                    imgObj.src = f.target.result;
                    imgObj.onload = () => {
                        // Extract RAW data for processing
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = imgObj.width;
                        tempCanvas.height = imgObj.height;
                        const ctx = tempCanvas.getContext('2d');
                        ctx.drawImage(imgObj, 0, 0);

                        originalFrameImageData = ctx.getImageData(0, 0, imgObj.width, imgObj.height);
                        // deep copy for current state
                        currentFrameImageData = new ImageData(
                            new Uint8ClampedArray(originalFrameImageData.data),
                            originalFrameImageData.width,
                            originalFrameImageData.height
                        );

                        // Update Canvas base size to match image
                        canvasBaseWidth = imgObj.width;
                        canvasBaseHeight = imgObj.height;

                        // IMPORTANT: Set internal resolution
                        canvas.setDimensions({ width: canvasBaseWidth, height: canvasBaseHeight });

                        resizeCanvas(); // Update UI aspect ratio

                        // Setup Fabric Object
                        if (frameImgObj) canvas.remove(frameImgObj);

                        fabric.Image.fromURL(imgObj.src, (img) => {
                            frameImgObj = img;

                            // Scale logic: NO SCALING (Scale = 1)
                            // Image now matches canvas 1:1
                            img.set({
                                left: 0,
                                top: 0,
                                originX: 'left',
                                originY: 'top',
                                selectable: false,
                                hoverCursor: 'crosshair',
                                evented: true
                            });

                            canvas.add(img);
                            img.bringToFront();
                            applyModeSettings(); // Apply current mode
                            canvas.renderAll();
                            setLoading(false);
                        });
                    };
                };
                reader.readAsDataURL(file);
            });

            // -- Reset Logic --
            resetFrameBtn.addEventListener('click', () => {
                if (!frameImgObj || !originalFrameImageData) return;
                setLoading(true);

                // Restore logic
                currentFrameImageData = new ImageData(
                    new Uint8ClampedArray(originalFrameImageData.data),
                    originalFrameImageData.width,
                    originalFrameImageData.height
                );

                // Redraw original to temp canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = originalFrameImageData.width;
                tempCanvas.height = originalFrameImageData.height;
                const ctx = tempCanvas.getContext('2d');
                ctx.putImageData(currentFrameImageData, 0, 0);

                frameImgObj.setSrc(tempCanvas.toDataURL(), () => {
                    canvas.renderAll();
                    setLoading(false);
                });
            });

            // Tolerance Range UI
            thresholdRange.addEventListener('input', (e) => {
                thresholdValue.textContent = e.target.value;
            });

            // -- 2. Photo Upload Logic (Multiple) --
            uploadPhotoBtn.addEventListener('change', (e) => {
                const files = e.target.files;
                if (!files || files.length === 0) return;

                setLoading(true);
                let loadedCount = 0;

                Array.from(files).forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (f) => {
                        fabric.Image.fromURL(f.target.result, (img) => {
                            // Scale photos to be reasonable relative to the frame
                            // We use a safe fallback scale if frame not loaded yet
                            const baseW = canvasBaseWidth || 800;
                            const baseH = canvasBaseHeight || 800;
                            const scale = Math.max(baseW / img.width, baseH / img.height);
                            img.scale(scale * 0.5);

                            // Spread them out slightly
                            const offset = (Math.random() - 0.5) * (baseW * 0.1);

                            img.set({
                                left: baseW / 2 + offset,
                                top: baseH / 2 + offset,
                                originX: 'center',
                                originY: 'center',
                                selectable: true,
                                hasControls: true
                            });

                            canvas.add(img);
                            img.sendToBack();

                            loadedCount++;
                            if (loadedCount === files.length) {
                                if (frameImgObj) frameImgObj.bringToFront();
                                applyModeSettings(); // Apply current mode
                                canvas.renderAll();
                                setLoading(false);
                            }
                        });
                    };
                    reader.readAsDataURL(file);
                });

                photoName.textContent = `${files.length}æšè¿½åŠ ã—ã¾ã—ãŸ`;
            });

            // -- Delete Photo Logic --
            const deletePhotoBtn = document.getElementById('deletePhotoBtn');
            deletePhotoBtn.addEventListener('click', () => {
                const activeObjects = canvas.getActiveObjects();
                if (activeObjects.length) {
                    canvas.discardActiveObject();
                    activeObjects.forEach((obj) => {
                        if (obj !== frameImgObj) {
                            canvas.remove(obj);
                        }
                    });
                    canvas.renderAll();
                } else {
                    alert('å‰Šé™¤ã—ãŸã„å†™çœŸã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
                }
            });

            // Keyboard delete support
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    const activeObjects = canvas.getActiveObjects();
                    if (activeObjects.length) {
                        activeObjects.forEach((obj) => {
                            if (obj !== frameImgObj) {
                                canvas.remove(obj);
                            }
                        });
                        canvas.discardActiveObject();
                        canvas.renderAll();
                    }
                }
            });

            // -- 3. Layer / Events --
            canvas.on('object:modified', () => {
                // Keep frame on top
                if (frameImgObj) frameImgObj.bringToFront();
            });

            // -- 4. Download --
            saveBtn.addEventListener('click', () => {
                // Check if any object exists
                if (canvas.getObjects().length === 0) {
                    alert('ç”»åƒãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
                    return;
                }
                canvas.discardActiveObject();
                canvas.renderAll();
                const dataURL = canvas.toDataURL({ format: 'png', quality: 1, multiplier: 1 });
                const link = document.createElement('a');
                link.download = 'composite-magic-frame.png';
                link.href = dataURL;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
        });
    </script>
</body>

</html>